"""GitHub issue filing for upstream bug reports."""

import os
import json
from dataclasses import dataclass
from typing import Any

import requests


@dataclass
class IssueReport:
    """A potential bug to report upstream."""

    validator: str
    test_case: str
    variable: str
    expected: float
    actual: float
    difference: float
    citation: str | None
    inputs: dict[str, Any]
    claude_confidence: float | None

    def to_markdown(self) -> tuple[str, str]:
        """Generate issue title and body in markdown."""
        title = f"[cosilico-validators] Potential calculation discrepancy: {self.variable} in {self.test_case}"

        body = f"""## Automated Bug Report

This issue was automatically generated by [cosilico-validators](https://github.com/CosilicoAI/cosilico-validators), a multi-system tax/benefit validation framework.

### Summary
A potential calculation discrepancy was detected when validating against authoritative sources.

### Details

| Field | Value |
|-------|-------|
| **Test Case** | {self.test_case} |
| **Variable** | `{self.variable}` |
| **Expected (from statute)** | ${self.expected:,.2f} |
| **Calculated by {self.validator}** | ${self.actual:,.2f} |
| **Difference** | ${self.difference:,.2f} |
| **Claude Confidence** | {f"{self.claude_confidence:.1%}" if self.claude_confidence else "N/A"} |

### Legal Citation
{self.citation or "Not provided"}

### Test Inputs
```json
{json.dumps(self.inputs, indent=2)}
```

### Why this might be a bug
Our multi-system consensus engine detected that the expected value (derived from statutory text) differs significantly from this validator's calculation. When Claude's encoding confidence is high (>90%) and multiple validators disagree, this may indicate an issue in the implementation.

### Possible explanations
1. **Bug in validator implementation** - The calculation logic may not match the statute
2. **Edge case not handled** - The specific combination of inputs triggers an unhandled scenario
3. **Parameter out of date** - Tax parameters may need updating for the given year
4. **Our encoding error** - The expected value in our test case may be incorrect

### How to reproduce
Run the validation with these inputs for the `{self.variable}` variable.

---
*Generated by cosilico-validators. Please verify this is a valid issue before addressing.*
"""
        return title, body


# Mapping from validator names to GitHub repos
VALIDATOR_REPOS = {
    "PolicyEngine": "PolicyEngine/policyengine-us",
    "TAXSIM": None,  # TAXSIM doesn't have a public issue tracker
    "TaxAct": None,  # Commercial, no public repo
}


class GitHubIssueManager:
    """Manages filing issues to upstream repositories."""

    def __init__(self, token: str | None = None):
        """Initialize with GitHub token.

        Args:
            token: GitHub personal access token. If not provided,
                   looks for GITHUB_TOKEN environment variable.
        """
        self.token = token or os.environ.get("GITHUB_TOKEN")
        self.api_base = "https://api.github.com"
        self._filed_issues: list[dict] = []

    def _headers(self) -> dict[str, str]:
        headers = {
            "Accept": "application/vnd.github.v3+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }
        if self.token:
            headers["Authorization"] = f"Bearer {self.token}"
        return headers

    def create_issue_report(self, bug: dict[str, Any]) -> IssueReport:
        """Create an IssueReport from a potential bug dict."""
        return IssueReport(
            validator=bug["validator"],
            test_case=bug["test_case"],
            variable=bug.get("variable", "unknown"),
            expected=bug["expected"],
            actual=bug["actual"],
            difference=bug["difference"],
            citation=bug.get("citation"),
            inputs=bug.get("inputs", {}),
            claude_confidence=bug.get("claude_confidence"),
        )

    def file_issue(
        self,
        report: IssueReport,
        repo: str | None = None,
        labels: list[str] | None = None,
        dry_run: bool = False,
    ) -> dict | None:
        """File an issue to GitHub.

        Args:
            report: The issue report to file
            repo: Override repo (default: look up by validator)
            labels: Labels to add to the issue
            dry_run: If True, don't actually file, just return what would be filed

        Returns:
            GitHub API response or issue preview dict
        """
        # Determine target repo
        if repo is None:
            repo = VALIDATOR_REPOS.get(report.validator)

        if repo is None:
            return {
                "error": f"No GitHub repo configured for {report.validator}",
                "skipped": True,
            }

        title, body = report.to_markdown()

        issue_data = {
            "title": title,
            "body": body,
            "labels": labels or ["bug", "automated"],
        }

        if dry_run:
            return {
                "dry_run": True,
                "repo": repo,
                "issue": issue_data,
            }

        if not self.token:
            return {
                "error": "No GitHub token provided. Set GITHUB_TOKEN environment variable.",
                "skipped": True,
            }

        # Check for duplicates first
        existing = self._check_duplicate(repo, title)
        if existing:
            return {
                "duplicate": True,
                "existing_issue": existing,
            }

        # File the issue
        url = f"{self.api_base}/repos/{repo}/issues"
        response = requests.post(url, json=issue_data, headers=self._headers())

        if response.status_code == 201:
            result = response.json()
            self._filed_issues.append({
                "repo": repo,
                "number": result["number"],
                "url": result["html_url"],
            })
            return result
        else:
            return {
                "error": f"Failed to create issue: {response.status_code}",
                "response": response.text,
            }

    def _check_duplicate(self, repo: str, title: str) -> dict | None:
        """Check if a similar issue already exists."""
        # Search for issues with similar title
        search_query = f"repo:{repo} is:issue in:title {title[:50]}"
        url = f"{self.api_base}/search/issues"
        params = {"q": search_query}

        response = requests.get(url, params=params, headers=self._headers())
        if response.status_code == 200:
            results = response.json()
            if results.get("total_count", 0) > 0:
                return results["items"][0]
        return None

    def file_all_bugs(
        self,
        bugs: list[dict[str, Any]],
        dry_run: bool = False,
        confidence_threshold: float = 0.9,
    ) -> list[dict]:
        """File issues for all potential bugs above confidence threshold.

        Args:
            bugs: List of potential bug dicts from validation results
            dry_run: If True, don't actually file issues
            confidence_threshold: Only file if Claude confidence >= this

        Returns:
            List of results for each bug
        """
        results = []
        for bug in bugs:
            confidence = bug.get("claude_confidence", 0)
            if confidence < confidence_threshold:
                results.append({
                    "skipped": True,
                    "reason": f"Confidence {confidence:.1%} below threshold {confidence_threshold:.1%}",
                    "bug": bug,
                })
                continue

            report = self.create_issue_report(bug)
            result = self.file_issue(report, dry_run=dry_run)
            result["bug"] = bug
            results.append(result)

        return results

    @property
    def filed_issues(self) -> list[dict]:
        """Get list of successfully filed issues in this session."""
        return self._filed_issues
